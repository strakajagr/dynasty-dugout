#!/usr/bin/env python3
"""
Dynasty Dugout FastAPI Application - Main App
Serverless architecture with Aurora Serverless v2
FIXED: Delegates all league routing to main leagues router
ADDED: Player profile endpoints registration
"""
import logging
import sys
from datetime import datetime, timedelta
from routers import user_settings
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from mangum import Mangum
from typing import Optional, List, Dict, Any

# Configure logging
logging.basicConfig(level=logging.INFO, stream=sys.stdout)
logger = logging.getLogger(__name__)

# --- Early Database Setup ---
from core.database import execute_sql, test_database_connection

# =============================================================================
# DATABASE MIGRATIONS
# =============================================================================
def run_db_migrations():
    """Ensure all required columns and tables exist in the database."""
    logger.info("üîÑ Running database migrations...")
    
    # Column migrations
    column_migrations = [
        "ALTER TABLE user_leagues ADD COLUMN IF NOT EXISTS creation_status VARCHAR(50) DEFAULT 'completed'",
        "ALTER TABLE user_leagues ADD COLUMN IF NOT EXISTS creation_error_message TEXT",
        "ALTER TABLE user_leagues ADD COLUMN IF NOT EXISTS status_last_updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
        "ALTER TABLE user_leagues ADD COLUMN IF NOT EXISTS league_status VARCHAR(20) DEFAULT 'setup'",
        "ALTER TABLE league_memberships ADD COLUMN IF NOT EXISTS is_active BOOLEAN DEFAULT true"
    ]
    
    # NEW: Table creations for dashboard features
    table_migrations = [
        """CREATE TABLE IF NOT EXISTS league_transactions (
            transaction_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            league_id UUID NOT NULL,
            player_id INTEGER NOT NULL,
            team_id UUID,
            transaction_type VARCHAR(10) NOT NULL,
            transaction_date TIMESTAMP DEFAULT NOW(),
            created_at TIMESTAMP DEFAULT NOW()
        )""",
        
        """CREATE TABLE IF NOT EXISTS player_injuries (
            player_id INTEGER PRIMARY KEY,
            full_name VARCHAR(100),
            position VARCHAR(20),
            team VARCHAR(10),
            injury_status VARCHAR(20),
            injury_description TEXT,
            expected_return DATE,
            active BOOLEAN DEFAULT true,
            updated_at TIMESTAMP DEFAULT NOW()
        )""",
        
        """CREATE TABLE IF NOT EXISTS ticker_alerts (
            alert_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            alert_text TEXT NOT NULL,
            priority VARCHAR(10) DEFAULT 'medium',
            alert_type VARCHAR(20),
            active BOOLEAN DEFAULT true,
            created_at TIMESTAMP DEFAULT NOW()
        )""",
        
        """CREATE TABLE IF NOT EXISTS player_trending_stats (
            player_id INTEGER,
            period VARCHAR(20),
            stat_date DATE,
            avg_change_7d DECIMAL(5,3),
            ops_change_7d DECIMAL(5,3),
            hr_change_7d INTEGER,
            rbi_change_7d INTEGER,
            PRIMARY KEY (player_id, period, stat_date)
        )"""
    ]
    
    # Run column migrations
    for migration_sql in column_migrations:
        try:
            execute_sql(migration_sql, database_name='postgres')
            logger.info(f"‚úÖ Migration applied: {migration_sql[:50]}...")
        except Exception as e:
            if "already exists" in str(e).lower():
                logger.info(f"‚úì Column already exists, skipping")
            else:
                logger.warning(f"Migration warning: {str(e)[:100]}")
    
    # Run table migrations
    for migration_sql in table_migrations:
        try:
            execute_sql(migration_sql, database_name='postgres')
            logger.info(f"‚úÖ Table migration applied")
        except Exception as e:
            if "already exists" in str(e).lower():
                logger.info(f"‚úì Table already exists, skipping")
            else:
                logger.warning(f"Table migration warning: {str(e)[:100]}")
    
    # Create indexes for performance
    index_migrations = [
        "CREATE INDEX IF NOT EXISTS idx_transactions_date ON league_transactions(transaction_date)",
        "CREATE INDEX IF NOT EXISTS idx_transactions_player ON league_transactions(player_id)",
        "CREATE INDEX IF NOT EXISTS idx_injuries_active ON player_injuries(active)",
        "CREATE INDEX IF NOT EXISTS idx_alerts_created ON ticker_alerts(created_at)",
        "CREATE INDEX IF NOT EXISTS idx_trending_date ON player_trending_stats(stat_date)"
    ]
    
    for index_sql in index_migrations:
        try:
            execute_sql(index_sql, database_name='postgres')
        except Exception as e:
            if "already exists" in str(e).lower():
                pass
            else:
                logger.warning(f"Index creation warning: {str(e)[:50]}")
    
    logger.info("‚úÖ Database migrations complete")

# Run migrations on cold start
run_db_migrations()

# =============================================================================
# IMPORT ROUTERS
# =============================================================================
logger.info("üì¶ Importing routers...")

# Standard routers
try:
    from routers import auth
    from routers import account
    from routers import analytics
    from routers import utilities
    from routers import invitations
    logger.info("‚úÖ Standard routers imported")
except Exception as e:
    logger.critical(f"‚ùå Failed to import standard routers: {e}", exc_info=True)
    sys.exit(1)

# Main leagues router (handles all league functionality internally)
try:
    from routers import leagues
    logger.info("‚úÖ Main leagues router imported")
except Exception as e:
    logger.critical(f"‚ùå Failed to import main leagues router: {e}", exc_info=True)
    sys.exit(1)

# Player endpoints router - ADDED
try:
    from routers.leagues import players
    logger.info("‚úÖ Players router imported")
except Exception as e:
    logger.critical(f"‚ùå Failed to import players router: {e}", exc_info=True)
    sys.exit(1)

# =============================================================================
# FASTAPI APP
# =============================================================================
app = FastAPI(
    title="Dynasty Dugout API",
    version="7.1.0",
    description="Serverless fantasy baseball platform with enhanced dashboard features and player profiles"
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://d20wx6xzxkf84y.cloudfront.net",
        "https://d31ij4udqr5ude.cloudfront.net",
        "https://dynasty-dugout.com",
        "https://www.dynasty-dugout.com",
        "http://localhost:3000",
        "http://localhost:3001"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# =============================================================================
# REGISTER ROUTERS
# =============================================================================
logger.info("üîå Registering API routes...")

# Authentication & Account
app.include_router(auth.router, prefix="/api/auth", tags=["Authentication"])
app.include_router(account.router, prefix="/api/account", tags=["Account"])

# Main leagues router (delegates to all league sub-modules internally)
app.include_router(leagues.router, prefix="/api/leagues", tags=["Leagues"])

# Player endpoints - ADDED
app.include_router(players.global_router, prefix="/api/players", tags=["Players"])

# Analytics & Utilities
app.include_router(analytics.router, prefix="/api/analytics", tags=["Analytics"])
app.include_router(invitations.router, prefix="/api/invitation", tags=["Invitations"])
app.include_router(utilities.router, prefix="/api/utilities", tags=["Utilities"])
app.include_router(user_settings.router, prefix="/api/user", tags=["User Settings"])

logger.info("‚úÖ All routers registered")

# =============================================================================
# DASHBOARD ENDPOINTS
# =============================================================================

@app.get("/api/stats/trending")
async def get_trending_players():
    """Get hot and cold players based on rolling stats changes"""
    try:
        # Hot players - biggest gainers in last 7 days
        hot_sql = """
            WITH current_stats AS (
                SELECT 
                    pr.player_id,
                    pr.batting_avg,
                    pr.ops,
                    pr.home_runs,
                    pr.rbi,
                    pr.runs,
                    pr.stolen_bases
                FROM player_rolling_stats pr
                WHERE pr.period = 'last_14_days' 
                AND pr.as_of_date = (SELECT MAX(as_of_date) FROM player_rolling_stats)
            ),
            previous_stats AS (
                SELECT 
                    pr.player_id,
                    pr.batting_avg as prev_avg,
                    pr.ops as prev_ops
                FROM player_rolling_stats pr
                WHERE pr.period = 'last_14_days' 
                AND pr.as_of_date = (SELECT MAX(as_of_date) - INTERVAL '7 days' FROM player_rolling_stats)
            )
            SELECT 
                c.player_id,
                p.full_name as name,
                p.position,
                p.team,
                c.batting_avg,
                c.ops,
                c.home_runs as hr,
                c.rbi,
                ROUND((c.batting_avg - ps.prev_avg)::numeric, 3) as avg_change,
                ROUND((c.ops - ps.prev_ops)::numeric, 3) as ops_change
            FROM current_stats c
            JOIN previous_stats ps ON c.player_id = ps.player_id
            JOIN mlb_players p ON c.player_id = p.player_id
            WHERE c.batting_avg IS NOT NULL
            ORDER BY (c.batting_avg - ps.prev_avg) DESC
            LIMIT 5
        """
        
        # Cold players - biggest drops
        cold_sql = """
            WITH current_stats AS (
                SELECT 
                    pr.player_id,
                    pr.batting_avg,
                    pr.ops,
                    pr.home_runs,
                    pr.rbi,
                    pr.runs,
                    pr.stolen_bases
                FROM player_rolling_stats pr
                WHERE pr.period = 'last_14_days' 
                AND pr.as_of_date = (SELECT MAX(as_of_date) FROM player_rolling_stats)
            ),
            previous_stats AS (
                SELECT 
                    pr.player_id,
                    pr.batting_avg as prev_avg,
                    pr.ops as prev_ops
                FROM player_rolling_stats pr
                WHERE pr.period = 'last_14_days' 
                AND pr.as_of_date = (SELECT MAX(as_of_date) - INTERVAL '7 days' FROM player_rolling_stats)
            )
            SELECT 
                c.player_id,
                p.full_name as name,
                p.position,
                p.team,
                c.batting_avg,
                c.ops,
                c.home_runs as hr,
                c.rbi,
                ROUND((c.batting_avg - ps.prev_avg)::numeric, 3) as avg_change,
                ROUND((c.ops - ps.prev_ops)::numeric, 3) as ops_change
            FROM current_stats c
            JOIN previous_stats ps ON c.player_id = ps.player_id
            JOIN mlb_players p ON c.player_id = p.player_id
            WHERE c.batting_avg IS NOT NULL
            ORDER BY (c.batting_avg - ps.prev_avg) ASC
            LIMIT 5
        """
        
        hot_result = execute_sql(hot_sql, database_name='postgres')
        cold_result = execute_sql(cold_sql, database_name='postgres')
        
        # Parse results
        hot_players = []
        if hot_result and hot_result.get("records"):
            for record in hot_result["records"]:
                hot_players.append({
                    "player_id": record[0].get("longValue"),
                    "name": record[1].get("stringValue"),
                    "position": record[2].get("stringValue"),
                    "team": record[3].get("stringValue"),
                    "last_7": {
                        "avg": float(record[4].get("stringValue", 0)) if record[4].get("stringValue") else 0,
                        "ops": float(record[5].get("stringValue", 0)) if record[5].get("stringValue") else 0,
                        "hr": record[6].get("longValue", 0),
                        "rbi": record[7].get("longValue", 0)
                    },
                    "change": {
                        "avg": f"+{record[8].get('stringValue', '0')}",
                        "trend": "up"
                    }
                })
        
        cold_players = []
        if cold_result and cold_result.get("records"):
            for record in cold_result["records"]:
                cold_players.append({
                    "player_id": record[0].get("longValue"),
                    "name": record[1].get("stringValue"),
                    "position": record[2].get("stringValue"),
                    "team": record[3].get("stringValue"),
                    "last_7": {
                        "avg": float(record[4].get("stringValue", 0)) if record[4].get("stringValue") else 0,
                        "ops": float(record[5].get("stringValue", 0)) if record[5].get("stringValue") else 0,
                        "hr": record[6].get("longValue", 0),
                        "rbi": record[7].get("longValue", 0)
                    },
                    "change": {
                        "avg": record[8].get("stringValue", "0"),
                        "trend": "down"
                    }
                })
        
        return {
            "success": True,
            "hot": hot_players,
            "cold": cold_players
        }
        
    except Exception as e:
        logger.error(f"Error getting trending players: {e}")
        return {
            "success": False,
            "hot": [],
            "cold": [],
            "error": str(e)
        }

@app.get("/api/waiver/trends")
async def get_waiver_trends():
    """Get most added and dropped players across all leagues today"""
    try:
        # Most added players
        adds_sql = """
            SELECT 
                lt.player_id,
                p.full_name as name,
                p.position,
                p.team,
                COUNT(*) as adds_today,
                ROUND(COUNT(*)::numeric / (SELECT COUNT(DISTINCT league_id) FROM user_leagues) * 100, 1) as ownership_pct
            FROM league_transactions lt
            JOIN mlb_players p ON lt.player_id = p.player_id
            WHERE lt.transaction_type = 'add'
            AND lt.transaction_date >= CURRENT_DATE
            GROUP BY lt.player_id, p.full_name, p.position, p.team
            ORDER BY adds_today DESC
            LIMIT 5
        """
        
        # Most dropped players
        drops_sql = """
            SELECT 
                lt.player_id,
                p.full_name as name,
                p.position,
                p.team,
                COUNT(*) as drops_today,
                ROUND(COUNT(*)::numeric / (SELECT COUNT(DISTINCT league_id) FROM user_leagues) * 100, 1) as ownership_pct
            FROM league_transactions lt
            JOIN mlb_players p ON lt.player_id = p.player_id
            WHERE lt.transaction_type = 'drop'
            AND lt.transaction_date >= CURRENT_DATE
            GROUP BY lt.player_id, p.full_name, p.position, p.team
            ORDER BY drops_today DESC
            LIMIT 5
        """
        
        adds_result = execute_sql(adds_sql, database_name='postgres')
        drops_result = execute_sql(drops_sql, database_name='postgres')
        
        # Parse results
        waiver_adds = []
        if adds_result and adds_result.get("records"):
            for record in adds_result["records"]:
                waiver_adds.append({
                    "player_id": record[0].get("longValue"),
                    "name": record[1].get("stringValue"),
                    "position": record[2].get("stringValue"),
                    "team": record[3].get("stringValue"),
                    "adds_today": record[4].get("longValue", 0),
                    "ownership": f"{record[5].get('stringValue', '0')}%",
                    "trend": f"+{record[4].get('longValue', 0)}"
                })
        
        waiver_drops = []
        if drops_result and drops_result.get("records"):
            for record in drops_result["records"]:
                waiver_drops.append({
                    "player_id": record[0].get("longValue"),
                    "name": record[1].get("stringValue"),
                    "position": record[2].get("stringValue"),
                    "team": record[3].get("stringValue"),
                    "drops_today": record[4].get("longValue", 0),
                    "ownership": f"{record[5].get('stringValue', '0')}%",
                    "trend": f"-{record[4].get('longValue', 0)}"
                })
        
        return {
            "success": True,
            "adds": waiver_adds,
            "drops": waiver_drops
        }
        
    except Exception as e:
        logger.error(f"Error getting waiver trends: {e}")
        return {
            "success": False,
            "adds": [],
            "drops": [],
            "error": str(e)
        }

@app.get("/api/injuries/today")
async def get_injury_report():
    """Get current injury report for all MLB players"""
    try:
        sql = """
            SELECT 
                player_id,
                full_name as name,
                position,
                team,
                injury_status as status,
                injury_description as injury,
                CASE 
                    WHEN expected_return IS NULL THEN 'TBD'
                    WHEN expected_return < CURRENT_DATE THEN 'Any day'
                    WHEN expected_return = CURRENT_DATE THEN 'Today'
                    ELSE TO_CHAR(expected_return, 'Mon DD')
                END as return_date
            FROM player_injuries
            WHERE active = true
            ORDER BY 
                CASE injury_status 
                    WHEN 'DTD' THEN 1 
                    WHEN 'IL-10' THEN 2 
                    WHEN 'IL-15' THEN 3 
                    WHEN 'IL-60' THEN 4 
                    ELSE 5
                END,
                expected_return ASC
            LIMIT 15
        """
        
        result = execute_sql(sql, database_name='postgres')
        
        injuries = []
        if result and result.get("records"):
            for record in result["records"]:
                injuries.append({
                    "player_id": record[0].get("longValue"),
                    "name": record[1].get("stringValue"),
                    "position": record[2].get("stringValue"),
                    "team": record[3].get("stringValue"),
                    "status": record[4].get("stringValue"),
                    "injury": record[5].get("stringValue"),
                    "return_date": record[6].get("stringValue")
                })
        
        return {
            "success": True,
            "injuries": injuries
        }
        
    except Exception as e:
        logger.error(f"Error getting injury report: {e}")
        return {
            "success": False,
            "injuries": [],
            "error": str(e)
        }

@app.get("/api/alerts/ticker")
async def get_ticker_alerts():
    """Get live ticker alerts for the dashboard"""
    try:
        sql = """
            SELECT 
                alert_id,
                alert_text as text,
                priority,
                alert_type,
                created_at
            FROM ticker_alerts
            WHERE active = true
            AND created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours'
            ORDER BY 
                CASE priority 
                    WHEN 'high' THEN 1 
                    WHEN 'medium' THEN 2 
                    WHEN 'low' THEN 3 
                    ELSE 4
                END,
                created_at DESC
            LIMIT 20
        """
        
        result = execute_sql(sql, database_name='postgres')
        
        alerts = []
        if result and result.get("records"):
            for record in result["records"]:
                alerts.append({
                    "id": record[0].get("stringValue"),
                    "text": record[1].get("stringValue"),
                    "priority": record[2].get("stringValue", "medium"),
                    "type": record[3].get("stringValue"),
                    "created_at": record[4].get("stringValue")
                })
        
        # If no alerts, provide some default ones
        if not alerts:
            alerts = [
                {"id": "1", "text": "Check out today's hot players in the trending section", "priority": "medium"},
                {"id": "2", "text": "Season is in full swing - set your lineups!", "priority": "low"},
                {"id": "3", "text": "Rolling stats updated daily at 2 AM ET", "priority": "low"}
            ]
        
        return {
            "success": True,
            "alerts": alerts
        }
        
    except Exception as e:
        logger.error(f"Error getting ticker alerts: {e}")
        return {
            "success": False,
            "alerts": [
                {"id": "error", "text": "Welcome to Dynasty Dugout!", "priority": "low"}
            ],
            "error": str(e)
        }

# =============================================================================
# ROOT ENDPOINTS
# =============================================================================
@app.get("/")
async def root():
    """Root endpoint"""
    return {
        "service": "Dynasty Dugout API",
        "version": "7.1.0",
        "status": "operational",
        "architecture": "serverless",
        "database": "Aurora Serverless v2"
    }

@app.get("/api")
async def api_root():
    """API root endpoint"""
    return {
        "message": "Dynasty Dugout API",
        "endpoints": {
            "auth": "/api/auth",
            "leagues": "/api/leagues",
            "players": "/api/players",
            "account": "/api/account",
            "health": "/api/health",
            "stats": "/api/stats",
            "waiver": "/api/waiver",
            "injuries": "/api/injuries",
            "alerts": "/api/alerts"
        }
    }

@app.get("/api/health")
async def health_check():
    """Comprehensive health check"""
    health_status = {
        "status": "healthy",
        "service": "Dynasty Dugout API",
        "version": "7.1.0",
        "checks": {}
    }
    
    # Database check
    try:
        if test_database_connection():
            health_status["checks"]["database"] = "connected"
            
            # Check critical tables
            result = execute_sql(
                "SELECT COUNT(*) FROM mlb_players WHERE is_active = true",
                database_name='postgres'
            )
            if result and result.get("records"):
                player_count = result["records"][0][0].get("longValue", 0)
                health_status["checks"]["mlb_players"] = f"{player_count} active"
            
            # Check new dashboard tables
            tables_to_check = ["league_transactions", "player_injuries", "ticker_alerts"]
            for table in tables_to_check:
                try:
                    result = execute_sql(f"SELECT COUNT(*) FROM {table}", database_name='postgres')
                    if result and result.get("records"):
                        count = result["records"][0][0].get("longValue", 0)
                        health_status["checks"][table] = f"{count} records"
                except:
                    health_status["checks"][table] = "not found"
                    
        else:
            health_status["checks"]["database"] = "disconnected"
            health_status["status"] = "degraded"
    except Exception as e:
        health_status["checks"]["database"] = f"error: {str(e)[:50]}"
        health_status["status"] = "unhealthy"
    
    # Lambda environment check
    import os
    health_status["checks"]["lambda"] = {
        "function": os.environ.get("AWS_LAMBDA_FUNCTION_NAME", "local"),
        "memory": os.environ.get("AWS_LAMBDA_FUNCTION_MEMORY_SIZE", "N/A"),
        "region": os.environ.get("AWS_REGION", "N/A")
    }
    
    return health_status

@app.get("/api/debug/routes")
async def debug_routes():
    """Debug endpoint to list all registered routes"""
    routes = []
    for route in app.routes:
        if hasattr(route, "path"):
            routes.append({
                "path": route.path,
                "methods": route.methods if hasattr(route, "methods") else None
            })
    return {"total_routes": len(routes), "routes": routes}

# =============================================================================
# LAMBDA HANDLER
# =============================================================================
handler = Mangum(app)
logger.info("üöÄ FastAPI app initialized with Mangum handler")

# =============================================================================
# LOCAL DEVELOPMENT
# =============================================================================
if __name__ == "__main__":
    import uvicorn
    logger.info("üèÉ Running in local development mode...")
    uvicorn.run("fantasy_api:app", host="0.0.0.0", port=8000, reload=True)